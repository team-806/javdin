/* 
 * CUP grammar file for Javdin language
 * This will be used to generate the parser
 */

package com.javdin.parser.generated;

import com.javdin.lexer.*;
import com.javdin.ast.*;
import java.util.List;
import java.util.ArrayList;

/* Terminals (tokens) */
terminal String IDENTIFIER;
terminal Integer INTEGER;
terminal Double REAL;
terminal String STRING;
terminal Boolean BOOL;

/* Keywords */
terminal VAR, IF, THEN, ELSE, END, WHILE, FOR, IN, LOOP, EXIT;
terminal FUNC, IS, RETURN, PRINT, TRUE, FALSE, NONE;

/* Type indicators */
terminal INT_TYPE, REAL_TYPE, BOOL_TYPE, STRING_TYPE, NONE_TYPE;
terminal ARRAY_TYPE, TUPLE_TYPE, FUNC_TYPE;

/* Operators */
terminal PLUS, MINUS, MULTIPLY, DIVIDE;
terminal ASSIGN_OP, EQUAL, NOT_EQUAL, NOT_EQUAL_ALT;
terminal LESS_THAN, LESS_EQUAL, GREATER_THAN, GREATER_EQUAL;
terminal AND, OR, XOR, NOT;
terminal RANGE, SHORT_IF;

/* Delimiters */
terminal LEFT_PAREN, RIGHT_PAREN;
terminal LEFT_BRACE, RIGHT_BRACE;
terminal LEFT_BRACKET, RIGHT_BRACKET;
terminal SEMICOLON, COMMA, DOT, COLON;

/* Special */
terminal NEWLINE;

/* Non-terminals */
non terminal ProgramNode program;
non terminal List<StatementNode> statement_list;
non terminal StatementNode statement;
non terminal ExpressionNode expression;
non terminal ExpressionNode relation;
non terminal ExpressionNode factor;
non terminal ExpressionNode term;
non terminal ExpressionNode unary;
non terminal ExpressionNode primary;
non terminal ExpressionNode reference;
non terminal ExpressionNode reference_base;
non terminal ExpressionNode literal;
non terminal String type_indicator;
non terminal ArrayLiteralNode array_literal;
non terminal TupleLiteralNode tuple_literal;
non terminal FunctionLiteralNode function_literal;
non terminal List<ExpressionNode> expression_list;
non terminal List<ExpressionNode> argument_list_opt;
non terminal List<ExpressionNode> argument_list;
non terminal List<TupleLiteralNode.TupleElement> tuple_element_list;
non terminal TupleLiteralNode.TupleElement tuple_element;
non terminal List<String> parameter_list_opt;
non terminal List<String> parameter_list;
non terminal List<DeclarationNode.VariableDefinition> variable_definition_list;
non terminal DeclarationNode.VariableDefinition variable_definition;
non terminal separator_opt;
non terminal separator_list;
non terminal separator;

/* Precedence declarations (lowest to highest) */
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL, NOT_EQUAL_ALT;
precedence left LESS_THAN, LESS_EQUAL, GREATER_THAN, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence right NOT;

/* Grammar rules */
program ::= statement_list:stmts
    {: RESULT = new ProgramNode(stmts, 1, 1); :}
    | /* empty */
    {: RESULT = new ProgramNode(new ArrayList<StatementNode>(), 1, 1); :};

/* Statement list with optional separators (semicolons or newlines) */
statement_list ::= 
    statement_list:list separator_opt statement:stmt separator_opt
    {: list.add(stmt); RESULT = list; :}
    | statement:stmt separator_opt
    {: List<StatementNode> list = new ArrayList<>(); 
       list.add(stmt); 
       RESULT = list; :};

/* Optional separators - one or more semicolons/newlines or nothing */
separator_opt ::=
    separator_list
    | /* empty */
    ;

separator_list ::=
    separator_list separator
    | separator
    ;

separator ::=
    SEMICOLON
    | NEWLINE
    ;

/* Statements - note: NO semicolons in statement productions */
statement ::= 
    VAR:v variable_definition_list:vars
    {: RESULT = new DeclarationNode(vars, vleft, vright); :}
    | PRINT:p expression_list:exprs
    {: RESULT = new PrintNode(pleft, pright, exprs); :};

/* Variable definition list: var x := 1, y := 2, z */
variable_definition_list ::=
    variable_definition_list:list COMMA variable_definition:def
    {: list.add(def); RESULT = list; :}
    | variable_definition:def
    {: List<DeclarationNode.VariableDefinition> list = new ArrayList<>();
       list.add(def);
       RESULT = list; :};

/* Single variable definition: name or name := expr */
variable_definition ::=
    IDENTIFIER:name ASSIGN_OP expression:expr
    {: RESULT = new DeclarationNode.VariableDefinition(name, expr); :}
    | IDENTIFIER:name
    {: RESULT = new DeclarationNode.VariableDefinition(name, null); :};

/* Expression grammar with proper precedence (per Project D spec) */
/* Expression: Relation { ( or | and | xor ) Relation } */
expression ::=
    expression:left OR relation:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "or", right); :}
    | expression:left XOR relation:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "xor", right); :}
    | expression:left AND relation:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "and", right); :}
    | relation:r
    {: RESULT = r; :}
    ;

/* Relation: Factor [ ( < | <= | > | >= | = | /= ) Factor ] */
relation ::=
    factor:left LESS_THAN factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "<", right); :}
    | factor:left LESS_EQUAL factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "<=", right); :}
    | factor:left GREATER_THAN factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, ">", right); :}
    | factor:left GREATER_EQUAL factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, ">=", right); :}
    | factor:left EQUAL factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "=", right); :}
    | factor:left NOT_EQUAL factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "/=", right); :}
    | factor:left NOT_EQUAL_ALT factor:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "/=", right); :}
    | factor:f
    {: RESULT = f; :}
    ;

/* Factor: Term { [ + | - ] Term } */
factor ::=
    factor:left PLUS term:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "+", right); :}
    | factor:left MINUS term:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "-", right); :}
    | term:t
    {: RESULT = t; :}
    ;

/* Term: Unary { ( * | / ) Unary } */
term ::=
    term:left MULTIPLY unary:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "*", right); :}
    | term:left DIVIDE unary:right
    {: RESULT = new BinaryOpNode(leftleft, leftright, left, "/", right); :}
    | unary:u
    {: RESULT = u; :}
    ;

/* Unary: Reference | Reference is TypeIndicator | [ + | - | not ] Primary */
unary ::=
    PLUS:op primary:expr
    {: RESULT = new UnaryOpNode(opleft, opright, "+", expr); :}
    | MINUS:op primary:expr
    {: RESULT = new UnaryOpNode(opleft, opright, "-", expr); :}
    | NOT:op primary:expr
    {: RESULT = new UnaryOpNode(opleft, opright, "not", expr); :}
    | reference:ref IS type_indicator:type
    {: RESULT = new TypeCheckNode(refleft, refright, ref, type); :}
    | primary:p
    {: RESULT = p; :}
    ;

/* Type indicators for 'is' operator */
type_indicator ::=
    INT_TYPE {: RESULT = "int"; :}
    | REAL_TYPE {: RESULT = "real"; :}
    | BOOL_TYPE {: RESULT = "bool"; :}
    | STRING_TYPE {: RESULT = "string"; :}
    | NONE_TYPE {: RESULT = "none"; :}
    | ARRAY_TYPE {: RESULT = "array"; :}
    | TUPLE_TYPE {: RESULT = "tuple"; :}
    | FUNC_TYPE {: RESULT = "func"; :}
    ;

/* Primary: Literal | FunctionLiteral | ( Expression ) */
primary ::=
    literal:lit
    {: RESULT = lit; :}
    | reference:ref
    {: RESULT = ref; :}
    | LEFT_PAREN:lp expression:expr RIGHT_PAREN
    {: RESULT = expr; :}
    ;

/* Reference: IDENT | Reference [ Expression ] | Reference ( ArgumentList ) | Reference . IDENT | Reference . INTEGER */
reference ::=
    reference_base:base
    {: RESULT = base; :}
    | reference:ref LEFT_BRACKET expression:index RIGHT_BRACKET
    {: RESULT = new ArrayAccessNode(refleft, refright, ref, index); :}
    | reference:ref LEFT_PAREN argument_list_opt:args RIGHT_PAREN
    {: RESULT = new FunctionCallNode(refleft, refright, ref, args); :}
    | reference:ref DOT IDENTIFIER:member
    {: RESULT = new TupleMemberAccessNode(refleft, refright, ref, member); :}
    | reference:ref DOT INTEGER:index
    {: RESULT = new TupleMemberAccessNode(refleft, refright, ref, index); :}
    ;

reference_base ::=
    IDENTIFIER:name
    {: RESULT = new ReferenceNode(nameleft, nameright, name); :}
    ;

/* Function call arguments */
argument_list_opt ::=
    argument_list:list
    {: RESULT = list; :}
    | /* empty */
    {: RESULT = new ArrayList<>(); :}
    ;

argument_list ::=
    argument_list:list COMMA expression:expr
    {: list.add(expr); RESULT = list; :}
    | expression:expr
    {: List<ExpressionNode> list = new ArrayList<>();
       list.add(expr);
       RESULT = list; :}
    ;

/* Literals: all literal types */
literal ::= INTEGER:val
    {: RESULT = new LiteralNode(val, LiteralNode.LiteralType.INTEGER, valleft, valright); :}
    | REAL:val
    {: RESULT = new LiteralNode(val, LiteralNode.LiteralType.REAL, valleft, valright); :}
    | STRING:val
    {: RESULT = new LiteralNode(val, LiteralNode.LiteralType.STRING, valleft, valright); :}
    | TRUE:t
    {: RESULT = new LiteralNode(true, LiteralNode.LiteralType.BOOLEAN, tleft, tright); :}
    | FALSE:f
    {: RESULT = new LiteralNode(false, LiteralNode.LiteralType.BOOLEAN, fleft, fright); :}
    | NONE:n
    {: RESULT = new LiteralNode(null, LiteralNode.LiteralType.NONE, nleft, nright); :}
    | array_literal:arr
    {: RESULT = arr; :}
    | tuple_literal:tup
    {: RESULT = tup; :}
    | function_literal:func
    {: RESULT = func; :};

/* Array literals: [1, 2, 3] or [] */
array_literal ::=
    ARRAY_TYPE:at
    {: RESULT = new ArrayLiteralNode(new ArrayList<>(), atleft, atright); :}
    | LEFT_BRACKET:lb RIGHT_BRACKET
    {: RESULT = new ArrayLiteralNode(new ArrayList<>(), lbleft, lbright); :}
    | LEFT_BRACKET:lb expression_list:exprs RIGHT_BRACKET
    {: RESULT = new ArrayLiteralNode(exprs, lbleft, lbright); :};

expression_list ::=
    expression_list:list COMMA expression:expr
    {: list.add(expr); RESULT = list; :}
    | expression:expr
    {: List<ExpressionNode> list = new ArrayList<>();
       list.add(expr);
       RESULT = list; :};

/* Tuple literals: {a := 1, b := 2} or {1, 2, 3} or {} */
tuple_literal ::=
    TUPLE_TYPE:tt
    {: RESULT = new TupleLiteralNode(new ArrayList<>(), ttleft, ttright); :}
    | LEFT_BRACE:lb RIGHT_BRACE
    {: RESULT = new TupleLiteralNode(new ArrayList<>(), lbleft, lbright); :}
    | LEFT_BRACE:lb tuple_element_list:elements RIGHT_BRACE
    {: RESULT = new TupleLiteralNode(elements, lbleft, lbright); :};

tuple_element_list ::=
    tuple_element_list:list COMMA tuple_element:elem
    {: list.add(elem); RESULT = list; :}
    | tuple_element:elem
    {: List<TupleLiteralNode.TupleElement> list = new ArrayList<>();
       list.add(elem);
       RESULT = list; :};

tuple_element ::=
    IDENTIFIER:name ASSIGN_OP expression:expr
    {: RESULT = new TupleLiteralNode.TupleElement(name, expr); :}
    | expression:expr
    {: RESULT = new TupleLiteralNode.TupleElement(null, expr); :};

/* Function literals: func(x, y) is ... end or func(x) => expr */
function_literal ::=
    FUNC:f parameter_list_opt:params IS statement_list:body END
    {: RESULT = new FunctionLiteralNode(fleft, fright, params, body, false); :}
    | FUNC:f parameter_list_opt:params SHORT_IF expression:expr
    {: RESULT = new FunctionLiteralNode(fleft, fright, params, expr, true); :};

parameter_list_opt ::=
    LEFT_PAREN parameter_list:params RIGHT_PAREN
    {: RESULT = params; :}
    | LEFT_PAREN RIGHT_PAREN
    {: RESULT = new ArrayList<>(); :}
    | /* empty - no parentheses */
    {: RESULT = new ArrayList<>(); :};

parameter_list ::=
    parameter_list:list COMMA IDENTIFIER:param
    {: list.add(param); RESULT = list; :}
    | IDENTIFIER:param
    {: List<String> list = new ArrayList<>();
       list.add(param);
       RESULT = list; :};

